<!DOCTYPE html>
<html lang="uk">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="style.css">
	<title>Document</title>
</head>
<body>
	<div class="form">
		<form id="searchForm">
			<label for="searchInput"></label>
			<input type="text" id="searchInput"> 
			<!-- oninput="search()" -->
			<button id="nextButton">Next</button>
			<button id="prevButton">Prev</button>
		</form>
	</div>
	<div id="content">
		<div>
			<h2>Методи взаємодії з користувачем</h2>
			<p><span>alert</span> - використовується для відображення спливаючого вікна з вказаним повідомленням</p>
			<p><span>prompt</span> - показує діалогове вікно, що запитує у користувача текстове введення</p>
			<p><span>confirm</span> - показує діалогове вікно з повідомленням та двома кнопками — "OK" та "Скасувати". Повертає `true` для "OK" та `false` для "Скасувати"</p>
		</div>
		<div>
			<h2>Типи даних</h2>
			<p><span>number</span> - число</p>
			<p><span>string</span> - рядок</p>
			<p><span>boolean</span> - булевий тип</p>
			<p><span>null</span> - порожність</p>
			<p><span>undefined</span> - невизначеність</p>
			<p><span>symbol</span> - символ – доступний з ES2015</p>
			<p><span>bigint</span> - велике ціле – доступний з ES2020</p>
			<p><span>object</span> - об'єкт - складний тип даних, який представляє собою колекцію ключ-значення та може містити різні типи даних і функції.</p>
		</div>
		<div>
			<h2>Рядки та числа</h2>
			<p><span>typeof</span> - отримання поточного типу значення</p>
			<p><span>parseInt(value, radix)</span> - використовується для перетворення рядка в ціле число. Параметр `radix` визначає основу числової системи</p>
			<p><span>parseFloat(value)</span> - використовується для перетворення рядка в дробове число</p>
			<p><span>Number()</span> - використовується для явного перетворення в число</p>
			<p><span>String()</span> - використовується для явного перетворення в рядок</p>
			<p><span>str.charAt()</span> - отримати певний символ усередині рядка за індексом</p>
			<p><span>str.length</span> - довжина рядка</p>
			<p><span>str1.concat(str2)</span> - об'єднує один або декілька рядків, що передаються як аргументи до рядка, на якому викликається метод, повертаючи об'єднаний рядок.</p>
			<p><span>str.toLowerCase() та str.toUpperCase()</span> - відповідно перетворюють рядок на рядок із буквами у нижньому та верхньому регістрах. Ці методи не змінюють оригінальний рядок.</p>
			<p><span>str.includes(substr, index)</span> - перевіряє, чи заданий рядок, переданий як аргумент, присутній у іншому рядку. Пошук регістрозалежний, а значення повертається у вигляді логічного типу. Також ви можете вказати другий аргумент, що вказує на індекс, з якого почати пошук заданого рядка.</p>
			<p><span>str.ndexOf(substr, index)</span> - шукає підрядок і повертає перше входження підрядка в межах вихідного рядка. Він приймає необов'язковий параметр, який вказує на конкретний індекс для початку пошуку. повертає індекс першого входження підрядка.</p>
			<p><span>str.startsWith(substr, index)</span> - перевіряє, чи рядок починається з певної послідовності символів та повертає логічне значення. Пошук регістрозалежний. також приймає необов'язковий аргумент, який вказує позицію, з якої починається пошук для вказаного рядка.</p>
			<p><span>str.endsWith(substr, index)</span> - перевіряє, чи рядок закінчується певною послідовністю символів, повертаючи логічне значення. Також у цьому випадку пошук регістрозалежний. Необов'язковий аргумент вказує очікувану позицію кінця вказаного підрядка</p>
			<p><span>str.slice(indexStart, indexEnd)</span> - витягує частину рядка і повертає його як новий рядок. Не змінює вміст оригінального рядка.</p>
			<p><span>str.split('', number)</span> - приймає аргумент-роздільник і розбиває рядок відповідно до входження роздільника всередині рядка. Повертає масив рядків. Приймає необов'язковий аргумент, що вказує максимальну кількість елементів, які слід помістити всередину масиву.</p>
			<p><span>str.match(reg)</span> - шукає конкретний шаблон - переданий у вигляді регулярного виразу - всередині рядка та повертає масив із знайденими результатами</p>
			<p><span>reg.test(str)</span> - шукає конкретний патерн - переданий у вигляді регулярного виразу - всередині рядка та повертає логічне значення. Синтаксис є протилежним у порівнянні з методом match().</p>
			<p><span>str.replace(substr, replaceStr)</span> - знаходження певної підстроки або виразу в рядку та заміни її на інший рядок або значення. Цей метод не змінює початковий рядок, а створює новий рядок із заміненим вмістом.</p>
		</div>
		<div>
			<h2>Умовні оператори</h2>
			<p><span>if (condition) {} else if {};</span> - оператор if виконує блок коду, якщо умова є істинною, якщо умова є false, оператор if...else виконує блок коду, який слідує за гілкою else</p>
			<p><span>switch (key) {case value: break; default: break;}</span> - альтернатива послідовності операторів `if...else`</p>
			<p><span>const tern = condition ? true : false;</span> тернарний оператор</p>
		</div>
		<div>
			<h2>Цикли</h2>
			<p><span>for (let i = 0; i < arr.length; i++) {statement;}</span> - цикл for</p>
			<p><span>while (condition) {statement;}</span> - цикл while перевіряє умову: умова true - виконуємо дію</p>
			<p><span>do {statement;} while (condition);</span> - цикл do while: спочатку виконує першу дію, потім перевіряє умову </p>
			<p><span>for (const key in obj) {statement;}</span> - for in цикл для об'єктів</p>
			<h3>Оператори преривання</h3>
			<p><span>break</span> - команда, яка прериває виконання циклу, такого як for, do...while, while, switch або вказаної мітки</p>
			<p><span>continue</span> - припиняє виконання поточної ітерації у циклі, таких як for, while та do...while, і негайно продовжує виконання наступної ітерації</p>
		</div>
		<div>
			<h2>Функції</h2>
			<p><span>function name(params) {condition}</span> - Function declaration - визначає ім'я функції за допомогою ключового слова `function`. Зазвичай вони піднімаються (hoisted), що означає, що вони доступні в усій області, в якій вони визначені, навіть якщо вони оголошені після їх використання.</p>
			<p><span>const name = function(params) {condition}</span> - Function Expression не піднімаються і можуть бути використані лише після того, як вони визначені.</p>
			<p><span>const name = (params) => {condition}</span> - Arrow functions - це компактний спосіб написання функцій. Якщо тіло функції містить лише один вираз, він неявно повертається. Також не піднімаються і можуть бути використані лише після того, як вони визначені. Не мають свого 'this' при роботі з об'єктами</p>
			<p><span>function() {}</span> - Anonymous function - функція без назви, визначаються за допомогою виразів функцій та призначаються змінним або передаються як аргументи іншим функціям, використовуються в ситуаціях, де тимчасово потрібна функція або де функція не буде повторно використана.</p>
			<p><span>Callback functions</span> - це функції, які передаються як аргументи іншим функціям</p>
			<p><span>return</span> - прериває виконання функції та повертає значення</p>
			<h3>Параметри та аргументи</h3>
			<p><span>Параметри</span>- це "внутрішні змінні", вказані в оголошенні функції. Вони представляють значення, які функція очікує отримати під час виклику, визначаються всередині дужок оголошення функції.</p>
			<p><span>Аргументи</span> - це фактичні значення, що подаються до функції при її виклику. Вони замінюють параметри всередині функції, вказуються всередині дужок під час виклику функції, у відповідності до порядку параметрів функції.</p>
		</div>
		<div>
			<h2>Arrays</h2>
			<p><span>Array.isArray()</span> - перевірити, чи вкладене є масивом.</p>
			<p><span>arr[0]</span> - доступ до елементів масиву</p>
			<p><span>arr.length</span> - довжина масиву</p>
			<h3>Добавити чи видалити</h3>
			<p><span>arr.push()</span> - додавання елементів до масиву з кінця</p>
			<p><span>arr.unshift()</span> - додавання елементів до масиву з початку</p>
			<p><span>arr.pop()</span> - видалення останнього елементу з масиву</p>
			<p><span>arr.shift()</span> - видалення першого елементу з масиву</p>
			<p><span>arr.splice(start, num, replace)</span> - видалення та заміна елементів за параметрами: 1- індекс звідки почати, 2- кількість видаляємих елементів, 3..- елементи, якими потрібно замінити</p>
			<p><span>arr.slice(start, end)</span> - робить копію (вирізає) за параметрами: 1-початок, 2- кінець, не включно</p>
			<p><span>arr.join()</span> - забезпечує простий та ефективний спосіб об'єднання елементів масиву в рядок за допомогою вибраного роздільника</p>
			<p><span>arr.concat()</span> - об'єднання двох масивів</p>
			<h3>Цикли</h3>
			<p><span>arr.map(() => {})</span> - перебирає масив, виконує функцію для кожного елементу, повертає новий масив</p>
			<p><span>arr.filter(() => {})</span> - перебирає масив, перевіряє відповідність логічній умові і повертає новий масив відсортованих елементів.</p>
			<p><span>arr.reduce()</span> - зменшує масив значень до одного значення, викликається для кожного елемента масиву для отримання єдиного вихідного значення. Цей метод не змінює оригінальний масив.</p>
			<h3>Сортування</h3>
			<p><span>arr.sort()</span> - використовується для сортування масиву. За замовчуванням він сортує масив у порядку зростання.</p>
			<p><span>arr.reverse()</span> - змінити порядок елементів у масиві на зворотній</p>
			<h3>Перевірка та пошук</h3>
			<p><span>arr.every()</span> - використовується для перевірки того, чи всі елементи в масиві задовольняють певний тест, реалізований за допомогою наданої функції. Він повертає значення типу boolean, яке вказує, чи всі елементи відповідають зазначеній умові. Метод `every()` припиняє виконання, якщо умова є `false` для будь-якого елемента. Якщо всі елементи відповідають умові, він повертає `true`.</p>
			<p><span>arr.some()</span> - використовується для перевірки, чи хоча б один елемент масиву задовольняє певний умовний критерій. Він повертає `true`, якщо хоча б один елемент відповідає умові, і `false`, якщо жоден елемент не задовольняє умові.</p>
			<p><span>arr.includes()</span> - використовується для перевірки того, чи масив містить конкретний елемент. Він повертає значення типу boolean, що вказує, чи зазначений елемент присутній в масиві чи ні.</p>
			<p><span>arr.find()</span> - використовуються для знаходження першого та останнього елементів відповідно, які задовольняють певний умовний критерій в масиві.</p>
			<p><span>arr.indexOf()</span> - використовується для знаходження індексу першого входження елемента в масиві. Якщо елемент не знайдено, метод повертає -1.</p>
			<p><span>arr.findIndex()</span> - використовується для знаходження індексу першого елемента в масиві, який задовольняє певний умовний критерій. Якщо елемент не знайдено, метод повертає -1.</p>
			<h3>Аргументи</h3>
			<p><span>arguments</span> - псевдо-масивов, який містить усі параметри, передані функції. Це дозволяє вам динамічно отримувати доступ до аргументів, навіть якщо вони не були явно вказані у списку параметрів функції. Об'єкт `arguments` доступний у всіх областях функцій. Ви можете отримати доступ до аргументів усередині функції за допомогою об'єкта `arguments`, який діє подібно до масиву.</p>
			<p><span>spread operator (`...`)</span> - використовується для розгортання або розширення елементів, таких як масиви чи об'єкти. Коли використовується в параметрах функції, його називають spread параметром. Коли в виклику - rest. Spread можна використовувати для конкатенації масивів та об'єктів чи створення поверхневої копії масиву.</p>
		</div>
		<div>
			<h2>Object</h2>
			<p><span>obj.prop та obj[prop]</span> - звернення до властивості об'єкта як для визначення, так і для перевизначення</p>
			<p><span>methods</span> - методи, це функції які присвоєні до значення об'єкта викликаються - obj.prop()</p>
			<p><span>this</span> - визначає, що метод звертається до властивостей саме цього об'єкту</p>
			<p><span>hasOwnProperty()</span> - перевірить, чи властивість належить саме об'єкту (власна властивість, повертає `true`, якщо властивість є власною) чи успадкована від прототипу.</p>
			<p><span>Object.values()</span> - повертає масив значень власних перераховуваних властивостей об'єкта в тому ж порядку, як при використанні циклу `for...in`.</p>
			<p><span>Object.keys()</span> - отримує всі ключі об'єкта та повертає їх у вигляді масиву.</p>
			<p><span>Object.entries()</span> - повертає масив пар `[ключ, значення]` у вигляді масиву власних перераховуваних властивостей об'єкта з рядковими ключами.</p>
			<h3>Перетворення об'єкта на масив</h3>
			<p><span>const keys = Object.keys(user);</span> - повертає масив ключів об'єкту</p>
			<p><span>const values = Object.values(user);</span> - повертає масив властивостей об'єкту</p>
			<p><span>const entries = Object.entries(user);</span> - повертає масив масивів - ключ/значення - об'єкту.</p>
			<p>const arr = ['a', 'b', 'c', 'a', 'a', 'b', 'b']</p>
			<p>const set1 = new Set(['a', 'b', 'c', 'a', 'a', 'b', 'b']);</p>
			<p>console.log([...set1])		найпростіший спосіб прибрати дублікати.</p>
		</div>
		<div>
			<h2>Date</h2>
			<p><span>new Date()</span> - Без аргументів – створити об'єкт Date з поточною датою та часом</p>
			<p><span>date.getTime()</span> - перетворити існуючий об'єкт 'Date' на таймстамп</p>
			<p><span>date.toLocaleString()</span> - перетворює дату в рядок, використовуючи конвенції поточної локалі.</p>
			<p><span>date.toLocaleDateString()</span> - повертає рядок лише з частиною дати, відформатований з урахуванням вказаної або типової локалі.</p>
			<p><span>date.toUTCString()</span> - повертає рядкове представлення дати відповідно до Координованого всесвітнього часу (UTC), відображаючи дату та час у часовому поясі UTC.</p>
			<p><span>date.getTimezoneOffset()</span> - повертає зміщення часового поясу в хвилинах для поточної локалі, вказуючи різницю в хвилинах між UTC та місцевим часовим поясом.</p>
		</div>
		<div>
			<h2>DOM</h2>
			<h3>BOM</h3>
			<p><span>window</span> - представляє вікно браузера та надає властивості та методи для управління аспектами браузера, такими як місцезнаходження, історія та навігація.</p>
			<p><span>location</span> - надає інформацію про URL поточного документа та дозволяє скриптам переходити за різними URL.</p>
			<p><span>navigator</span> - надає інформацію про браузер та пристрій користувача, включаючи назву браузера, версію та підтримані функції.</p>
			<p><span>screen</span> - надає інформацію про екран користувача, таку як ширина, висота та глибина кольору.</p>
			<p><span>history</span> - дозволяє скриптам взаємодіяти з історією браузера, забезпечуючи навігацію між раніше відвіданими сторінками.</p>
			<h3>DOM</h3>
			<p><span>Document</span> - Коли об'єкт типу document повертається, цей об'єкт стає кореневим об'єктом документа сам по собі</p>
			<p><span>Node</span> - Кожен об'єкт, розташований в межах документа, є вузлом. У HTML-документі об'єкт може бути вузлом елемента, текстовим вузлом або навіть вузлом атрибута</p>
			<p><span>Element</span> - Тип елемента базується на вузлі. Це вказує на елемент, повернутий членом DOM API. Наприклад, замість того, щоб говорити, що метод document.createElement() повертає посилання на об'єкт вузла, ми можемо сказати, що цей метод повертає Element, який тільки що був створений в DOM.</p>
			<p><span>NodeList</span> - Список вузлів - це масив елементів. Елементи в списку вузлів можна отримати за індексом двома способами: list.item(1) або list[1]. У першому випадку item() - це єдиний метод об'єкта nodeList. У порівнянні інший використовує типовий синтаксис масиву для отримання другого елемента в списку</p>
			<p><span>Attribute або Attr</span> - Коли атрибут повертається (наприклад, методом createAttribute()), він діє як посилання на об'єкт, який викриває особливий вигляд для інших атрибутів.</p>
			<p><span>NamedNodeMap</span> - (Іменований вузловий масив) Іменований вузловий масив схожий на масив, але елементи звертаються за ім'ям або індексом. Елементи можна додавати або видаляти з іменованого вузлового масиву.</p>
			<h3>Пошук</h3>
			<p><span>document.getElementById(id)</span> - Знаходить елемент за його унікальним ідентифікатором (ID).</p>
			<p><span>document.getElementsByClassName(className)</span> - Повертає живий HTMLCollection елементів із вказаною назвою класу</p>
			<p><span>document.getElementsByTagName(tagName)</span> - Повертає живий HTMLCollection елементів із вказаним ім'ям тегу</p>
			<p><span>document.getElementsByName(name)</span> - повертає живий NodeList (колекцію вузлів), що представляє всі елементи із зазначеним іменем. Основним використанням getElementsByName є робота з елементами форми, такими як текстові поля, радіокнопки, прапорці та елементи вибору. У формових елементів часто є атрибут name, який корисно використовувати для ідентифікації та обробки даних на стороні сервера.</p>
			<p><span>document.querySelector(selector)</span> - Повертає перший елемент, який відповідає вказаному CSS-селектору</p>
			<p><span>document.querySelectorAll(selector)</span> - Повертає статичний NodeList, який представляє всі елементи, які відповідають вказаному CSS-селектору.</p>
			<p><span>elem.matches(css)</span> - не шукає нічого, він просто перевіряє, чи відповідає елемент вказаному CSS-селектору. Він повертає значення true або false. Цей метод стає в нагоді, коли ми перебираємо елементи (наприклад, у масиві чи іншій структурі даних) і намагаємося відфільтрувати ті, які нас цікавлять.</p>
			<p><span>elem.closest(css)</span> - шукає найближчого предка, який відповідає CSS-селектору. Сам елемент також включається у пошук.</p>
			<h3>Маніпуляція з елементом</h3>
			<p><span>innerHTML</span> - дозволяє отримувати HTML всередині елемента у вигляді рядка. Ми також можемо його змінювати. Таким чином, це один із найпотужніших способів змінювати сторінку.</p>
			<p><span>textContent</span> - часто використовується для отримання або встановлення текстового вмісту елемента HTML через JavaScript. Це надає засіб доступу та маніпулювання текстовим вмістом всередині елемента, не враховуючи теги HTML.</p>
			<p><span>innerText</span> - отримує або встановлює текстовий вміст елемента, враховуючи відображений текст на сторінці. Вона враховує стилізацію CSS і може виключати елементи, які стилізовані з використанням `display: none`.</p>
			<p>Використовуйте `innerHTML`, коли потрібно маніпулювати HTML-вмістом всередині елемента.</p>
			<p>Використовуйте `textContent`, коли хочете маніпулювати текстовим вмістом без врахування HTML-тегів.</p>
			<p>Використовуйте `innerText`, коли потрібно маніпулювати текстовим вмістом з урахуванням стилізації CSS та можливого виключення прихованих елементів.</p>
			<h3>Атрибути</h3>
			<p><span>elem.hasAttribute(name)</span> - перевіряє існування атрибута.</p>
			<p><span>elem.getAttribute(name)</span> - отримує значення атрибута.</p>
			<p><span>elem.setAttribute(name, value)</span> - встановлює значення атрибута.</p>
			<h3>Видалення</h3>
			<p><span>elem.removeAttribute(name)</span> - видаляє атрибут.</p>
			<p><span>node.remove()</span> - видалити вузол</p>
			<h3>Додавання класів</h3>
			<p><span>elem.classList.add/remove("class")</span> - додає/видаляє клас</p>
			<p><span>elem.classList.toggle("class")</span> - додає клас, якщо його немає, в іншому випадку видаляє.</p>
			<p><span>elem.classList.contains("class")</span> - перевіряє, чи є вказаний клас, повертає true/false.</p>
			<h3>Додавання стилів</h3>
			<p><span>elem.style</span> - об'єкт, який відповідає тому, що написано в атрибуті "style".</p>
			<p><span>getComputedStyle(element, [pseudo])</span> - element: Елемент, для якого потрібно отримати значення. pseudo: Псевдоелемент, якщо потрібно, наприклад, ::before. Порожній рядок або відсутність аргумента означає сам елемент.</p>
			<h3>Створення вузлів та елементів</h3>
			<p><span>document.createElement(tag)</span> - Створює новий вузол елемента з вказаним тегом</p>
			<p><span>document.createTextNode(text)</span> - Створює новий вузол тексту із заданим текстом</p>
			<h3>Додавання створених вузлів та елементів в документ</h3>
			<p><span>document.body.append(div)</span> - вставити створений вузол елемента в документ</p>
			<p><span>node.where(...nodes або strings)</span> - додає вузли або рядки в вузол. where:</p>
			<ul>
				<li><span>append</span> - додає вузли або рядки в кінець вузла</li>
				<li><span>prepend</span> - вставляє вузли або рядки в початок вузла</li>
				<li><span>before</span> - вставляє вузли або рядки перед вузлом</li>
				<li><span>after</span> - вставляє вузли або рядки після вузла</li>
				<li><span>replaceWith</span> - замінює вузол заданими вузлами або рядками</li>
			</ul>
			<p><span>elem.insertAdjacentHTML("where", html)</span> - універсальний метод додавання елементу. Використовується для не інтерактивних елементів. Перший елемент якого:</p>
			<ul>
				<li><span>beforebegin</span> – вставити html безпосередньо перед elem</li>
				<li><span>afterbegin</span> – вставити html в elem, на початку</li>
				<li><span>beforeend</span> – вставити html в elem, в кінці</li>
				<li><span>afterend</span> – вставити html безпосередньо після elem</li>
			</ul>
			<p>а другий елемент html - це рядок HTML, який вставляється "як HTML"</p>
			
			<p><span>cloneNode()</span> - дозволяє створювати копію вузла. Він приймає один аргумент - логічне значення, яке вказує, чи виконати глибоке або поверхневе копіювання: Якщо використовується cloneNode(true), створюється глибока копія, включаючи всі дочірні вузли та їх атрибути. Якщо використовується cloneNode(false) або просто cloneNode(), створюється поверхнева копія, копіюючи лише сам вузол і його атрибути</p>
			<p><span>createDocumentFragment()</span> - це частина моделі об'єкта документа (DOM), яка представляє собою легкий контейнер для утримання групи вузлів. На відміну від звичайного вузла, фрагмент документа не є частиною основного дерева документа, що може робити його більш ефективним для певних операцій, пов'язаних із зміною кількох вузлів.</p>
			<h3>Data-атрибути</h3>
			<p><span>data-*</span> - атрибути, що починаються з "data-", залишаються для використання програмістів. Вони доступні в властивості dataset.</p>
			<p><span></span> - </p>
			<p><span></span> - </p>
			<p><span></span> - </p>
			<p><span></span> - </p>
			<p><span></span> - </p>
			<p><span></span> - </p>
		</div>
	</div>
	<script src="script.js"></script>
</body>
</html>