<!DOCTYPE html>
<html lang="uk">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="style.css">
	<title>Document</title>
</head>
<body>
	<div>
		<form id="searchForm">
			<label for="searchInput">Пошук:</label>
			<input type="text" id="searchInput""> 
			<!-- oninput="search()" -->
		</form>
	</div>
	<div id="content">
		<div>
			<h2>Методи взаємодії з користувачем</h2>
			<p><span>alert</span> - використовується для відображення спливаючого вікна з вказаним повідомленням</p>
			<p><span>prompt</span> - показує діалогове вікно, що запитує у користувача текстове введення</p>
			<p><span>confirm</span> - показує діалогове вікно з повідомленням та двома кнопками — "OK" та "Скасувати". Повертає `true` для "OK" та `false` для "Скасувати"</p>
		</div>
		<div>
			<h2>Типи даних</h2>
			<p><span>number</span> - число</p>
			<p><span>string</span> - рядок</p>
			<p><span>boolean</span> - булевий тип</p>
			<p><span>null</span> - порожність</p>
			<p><span>undefined</span> - невизначеність</p>
			<p><span>symbol</span> - символ – доступний з ES2015</p>
			<p><span>bigint</span> - велике ціле – доступний з ES2020</p>
			<p><span>object</span> - об'єкт - складний тип даних, який представляє собою колекцію ключ-значення та може містити різні типи даних і функції.</p>
		</div>
		<div>
			<h2>Рядки та числа</h2>
			<p><span>typeof</span> - отримання поточного типу значення</p>
			<p><span>parseInt(value, radix)</span> - використовується для перетворення рядка в ціле число. Параметр `radix` визначає основу числової системи</p>
			<p><span>parseFloat(value)</span> - використовується для перетворення рядка в дробове число</p>
			<p><span>Number()</span> - використовується для явного перетворення в число</p>
			<p><span>String()</span> - використовується для явного перетворення в рядок</p>
		</div>
		<div>
			<h2>Умовні оператори</h2>
			<p><span>if (condition) {} else if {};</span> - оператор if виконує блок коду, якщо умова є істинною, якщо умова є false, оператор if...else виконує блок коду, який слідує за гілкою else</p>
			<p><span>switch (key) {case value: break; default: break;}</span> - альтернатива послідовності операторів `if...else`</p>
			<p><span>const tern = condition ? true : false;</span> тернарний оператор</p>
		</div>
		<div>
			<h2>Цикли</h2>
			<p><span>for (let i = 0; i < arr.length; i++) {statement;}</span> - цикл for</p>
			<p><span>while (condition) {statement;}</span> - цикл while перевіряє умову: умова true - виконуємо дію</p>
			<p><span>do {statement;} while (condition);</span> - цикл do while: спочатку виконує першу дію, потім перевіряє умову </p>
			<p><span>for (const key in obj) {statement;}</span> - for in цикл для об'єктів</p>
			<h3>Оператори преривання</h3>
			<p><span>break</span> - команда, яка прериває виконання циклу, такого як for, do...while, while, switch або вказаної мітки</p>
			<p><span>continue</span> - припиняє виконання поточної ітерації у циклі, таких як for, while та do...while, і негайно продовжує виконання наступної ітерації</p>
		</div>
		<div>
			<h2>Функції</h2>
			<p><span>function name(params) {condition}</span> - Function declaration - визначає ім'я функції за допомогою ключового слова `function`. Зазвичай вони піднімаються (hoisted), що означає, що вони доступні в усій області, в якій вони визначені, навіть якщо вони оголошені після їх використання.</p>
			<p><span>const name = function(params) {condition}</span> - Function Expression не піднімаються і можуть бути використані лише після того, як вони визначені.</p>
			<p><span>const name = (params) => {condition}</span> - Arrow functions - це компактний спосіб написання функцій. Якщо тіло функції містить лише один вираз, він неявно повертається. Також не піднімаються і можуть бути використані лише після того, як вони визначені. Не мають свого 'this' при роботі з об'єктами</p>
			<p><span>function() {}</span> - Anonymous function - функція без назви, визначаються за допомогою виразів функцій та призначаються змінним або передаються як аргументи іншим функціям, використовуються в ситуаціях, де тимчасово потрібна функція або де функція не буде повторно використана.</p>
			<p><span>Callback functions</span> - це функції, які передаються як аргументи іншим функціям</p>
			<p><span>return</span> - прериває виконання функції та повертає значення</p>
			<h3>Параметри та аргументи</h3>
			<p><span>Параметри</span>- це "внутрішні змінні", вказані в оголошенні функції. Вони представляють значення, які функція очікує отримати під час виклику, визначаються всередині дужок оголошення функції.</p>
			<p><span>Аргументи</span> - це фактичні значення, що подаються до функції при її виклику. Вони замінюють параметри всередині функції, вказуються всередині дужок під час виклику функції, у відповідності до порядку параметрів функції.</p>
		</div>
		<div>
			<h2>Arrays</h2>
			<p><span>Array.isArray()</span> - перевірити, чи вкладене є масивом.</p>
			<p><span>arr[0]</span> - доступ до елементів масиву</p>
			<p><span>arr.length</span> - довжина масиву</p>
			<h3>Добавити чи видалити</h3>
			<p><span>arr.push()</span> - додавання елементів до масиву з кінця</p>
			<p><span>arr.unshift()</span> - додавання елементів до масиву з початку</p>
			<p><span>arr.pop()</span> - видалення останнього елементу з масиву</p>
			<p><span>arr.shift()</span> - видалення першого елементу з масиву</p>
			<p><span>arr.splice(start, num, replace)</span> - видалення та заміна елементів за параметрами: 1- індекс звідки почати, 2- кількість видаляємих елементів, 3..- елементи, якими потрібно замінити</p>
			<p><span>arr.slice(start, end)</span> - робить копію (вирізає) за параметрами: 1-початок, 2- кінець, не включно</p>
			<p><span>arr.concat()</span> - об'єднання двох масивів</p>
			<h3></h3>
			<p><span>arr.map(() => {})</span> - перебирає масив, виконує функцію для кожного елементу, повертає новий масив</p>
			<p><span>arr.filter(() => {})</span> - перебирає масив, перевіряє відповідність логічній умові і повертає новий масив відсортованих елементів.</p>
		</div>
		<div>
			<h2>Object</h2>
			<p><span>obj.prop та obj[prop]</span> - звернення до властивості об'єкта як для визначення, так і для перевизначення</p>
			<h3>Перетворення об'єкта на масив</h3>
			<p><span>const keys = Object.keys(user);</span> - повертає масив ключів об'єкту</p>
			<p><span>const values = Object.values(user);</span> - повертає масив властивостей об'єкту</p>
			<p><span>const entries = Object.entries(user);</span> - повертає масив масивів - ключ/значення - об'єкту.</p>
			<p>const arr = ['a', 'b', 'c', 'a', 'a', 'b', 'b']</p>
				<p>const set1 = new Set(['a', 'b', 'c', 'a', 'a', 'b', 'b']);</p>
				<p>console.log([...set1])		найпростіший спосіб прибрати дублікати.</p>
				<script src="script.js"></script>
		</div>
	</div>
</body>
</html>