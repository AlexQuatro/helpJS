<!DOCTYPE html>
<html lang="uk">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="style.css">
	<title>Document</title>
</head>
<body>
	<div>
		<form id="searchForm">
			<label for="searchInput">Пошук:</label>
			<input type="text" id="searchInput""> 
			<!-- oninput="search()" -->
		</form>
	</div>
	<div id="content">
		<div>
			<h2>Методи взаємодії з користувачем</h2>
			<p><span>alert</span> - використовується для відображення спливаючого вікна з вказаним повідомленням</p>
			<p><span>prompt</span> - показує діалогове вікно, що запитує у користувача текстове введення</p>
			<p><span>confirm</span> - показує діалогове вікно з повідомленням та двома кнопками — "OK" та "Скасувати". Повертає `true` для "OK" та `false` для "Скасувати"</p>
		</div>
		<div>
			<h2>Типи даних</h2>
			<p><span>number</span> - число</p>
			<p><span>string</span> - рядок</p>
			<p><span>boolean</span> - булевий тип</p>
			<p><span>null</span> - порожність</p>
			<p><span>undefined</span> - невизначеність</p>
			<p><span>symbol</span> - символ – доступний з ES2015</p>
			<p><span>bigint</span> - велике ціле – доступний з ES2020</p>
			<p><span>object</span> - об'єкт - складний тип даних, який представляє собою колекцію ключ-значення та може містити різні типи даних і функції.</p>
		</div>
		<div>
			<h2>Рядки та числа</h2>
			<p><span>typeof</span> - отримання поточного типу значення</p>
			<p><span>parseInt(value, radix)</span> - використовується для перетворення рядка в ціле число. Параметр `radix` визначає основу числової системи</p>
			<p><span>parseFloat(value)</span> - використовується для перетворення рядка в дробове число</p>
			<p><span>Number()</span> - використовується для явного перетворення в число</p>
			<p><span>String()</span> - використовується для явного перетворення в рядок</p>
			<p><span>str.charAt()</span> - отримати певний символ усередині рядка за індексом</p>
			<p><span>str.length</span> - довжина рядка</p>
			<p><span>str1.concat(str2)</span> - об'єднує один або декілька рядків, що передаються як аргументи до рядка, на якому викликається метод, повертаючи об'єднаний рядок.</p>
			<p><span>str.toLowerCase() та str.toUpperCase()</span> - відповідно перетворюють рядок на рядок із буквами у нижньому та верхньому регістрах. Ці методи не змінюють оригінальний рядок.</p>
			<p><span>str.includes(substr, index)</span> - перевіряє, чи заданий рядок, переданий як аргумент, присутній у іншому рядку. Пошук регістрозалежний, а значення повертається у вигляді логічного типу. Також ви можете вказати другий аргумент, що вказує на індекс, з якого почати пошук заданого рядка.</p>
			<p><span>str.ndexOf(substr, index)</span> - шукає підрядок і повертає перше входження підрядка в межах вихідного рядка. Він приймає необов'язковий параметр, який вказує на конкретний індекс для початку пошуку. повертає індекс першого входження підрядка.</p>
			<p><span>str.startsWith(substr, index)</span> - перевіряє, чи рядок починається з певної послідовності символів та повертає логічне значення. Пошук регістрозалежний. також приймає необов'язковий аргумент, який вказує позицію, з якої починається пошук для вказаного рядка.</p>
			<p><span>str.endsWith(substr, index)</span> - перевіряє, чи рядок закінчується певною послідовністю символів, повертаючи логічне значення. Також у цьому випадку пошук регістрозалежний. Необов'язковий аргумент вказує очікувану позицію кінця вказаного підрядка</p>
			<p><span>str.slice(indexStart, indexEnd)</span> - витягує частину рядка і повертає його як новий рядок. Не змінює вміст оригінального рядка.</p>
			<p><span>str.split('', number)</span> - приймає аргумент-роздільник і розбиває рядок відповідно до входження роздільника всередині рядка. Повертає масив рядків. Приймає необов'язковий аргумент, що вказує максимальну кількість елементів, які слід помістити всередину масиву.</p>
			<p><span>str.match(reg)</span> - шукає конкретний шаблон - переданий у вигляді регулярного виразу - всередині рядка та повертає масив із знайденими результатами</p>
			<p><span>reg.test(str)</span> - шукає конкретний патерн - переданий у вигляді регулярного виразу - всередині рядка та повертає логічне значення. Синтаксис є протилежним у порівнянні з методом match().</p>
			<p><span>str.replace(substr, replaceStr)</span> - знаходження певної підстроки або виразу в рядку та заміни її на інший рядок або значення. Цей метод не змінює початковий рядок, а створює новий рядок із заміненим вмістом.</p>
		</div>
		<div>
			<h2>Умовні оператори</h2>
			<p><span>if (condition) {} else if {};</span> - оператор if виконує блок коду, якщо умова є істинною, якщо умова є false, оператор if...else виконує блок коду, який слідує за гілкою else</p>
			<p><span>switch (key) {case value: break; default: break;}</span> - альтернатива послідовності операторів `if...else`</p>
			<p><span>const tern = condition ? true : false;</span> тернарний оператор</p>
		</div>
		<div>
			<h2>Цикли</h2>
			<p><span>for (let i = 0; i < arr.length; i++) {statement;}</span> - цикл for</p>
			<p><span>while (condition) {statement;}</span> - цикл while перевіряє умову: умова true - виконуємо дію</p>
			<p><span>do {statement;} while (condition);</span> - цикл do while: спочатку виконує першу дію, потім перевіряє умову </p>
			<p><span>for (const key in obj) {statement;}</span> - for in цикл для об'єктів</p>
			<h3>Оператори преривання</h3>
			<p><span>break</span> - команда, яка прериває виконання циклу, такого як for, do...while, while, switch або вказаної мітки</p>
			<p><span>continue</span> - припиняє виконання поточної ітерації у циклі, таких як for, while та do...while, і негайно продовжує виконання наступної ітерації</p>
		</div>
		<div>
			<h2>Функції</h2>
			<p><span>function name(params) {condition}</span> - Function declaration - визначає ім'я функції за допомогою ключового слова `function`. Зазвичай вони піднімаються (hoisted), що означає, що вони доступні в усій області, в якій вони визначені, навіть якщо вони оголошені після їх використання.</p>
			<p><span>const name = function(params) {condition}</span> - Function Expression не піднімаються і можуть бути використані лише після того, як вони визначені.</p>
			<p><span>const name = (params) => {condition}</span> - Arrow functions - це компактний спосіб написання функцій. Якщо тіло функції містить лише один вираз, він неявно повертається. Також не піднімаються і можуть бути використані лише після того, як вони визначені. Не мають свого 'this' при роботі з об'єктами</p>
			<p><span>function() {}</span> - Anonymous function - функція без назви, визначаються за допомогою виразів функцій та призначаються змінним або передаються як аргументи іншим функціям, використовуються в ситуаціях, де тимчасово потрібна функція або де функція не буде повторно використана.</p>
			<p><span>Callback functions</span> - це функції, які передаються як аргументи іншим функціям</p>
			<p><span>return</span> - прериває виконання функції та повертає значення</p>
			<h3>Параметри та аргументи</h3>
			<p><span>Параметри</span>- це "внутрішні змінні", вказані в оголошенні функції. Вони представляють значення, які функція очікує отримати під час виклику, визначаються всередині дужок оголошення функції.</p>
			<p><span>Аргументи</span> - це фактичні значення, що подаються до функції при її виклику. Вони замінюють параметри всередині функції, вказуються всередині дужок під час виклику функції, у відповідності до порядку параметрів функції.</p>
		</div>
		<div>
			<h2>Arrays</h2>
			<p><span>Array.isArray()</span> - перевірити, чи вкладене є масивом.</p>
			<p><span>arr[0]</span> - доступ до елементів масиву</p>
			<p><span>arr.length</span> - довжина масиву</p>
			<h3>Добавити чи видалити</h3>
			<p><span>arr.push()</span> - додавання елементів до масиву з кінця</p>
			<p><span>arr.unshift()</span> - додавання елементів до масиву з початку</p>
			<p><span>arr.pop()</span> - видалення останнього елементу з масиву</p>
			<p><span>arr.shift()</span> - видалення першого елементу з масиву</p>
			<p><span>arr.splice(start, num, replace)</span> - видалення та заміна елементів за параметрами: 1- індекс звідки почати, 2- кількість видаляємих елементів, 3..- елементи, якими потрібно замінити</p>
			<p><span>arr.slice(start, end)</span> - робить копію (вирізає) за параметрами: 1-початок, 2- кінець, не включно</p>
			<p><span>arr.join()</span> - забезпечує простий та ефективний спосіб об'єднання елементів масиву в рядок за допомогою вибраного роздільника</p>
			<p><span>arr.concat()</span> - об'єднання двох масивів</p>
			<h3>Цикли</h3>
			<p><span>arr.map(() => {})</span> - перебирає масив, виконує функцію для кожного елементу, повертає новий масив</p>
			<p><span>arr.filter(() => {})</span> - перебирає масив, перевіряє відповідність логічній умові і повертає новий масив відсортованих елементів.</p>
			<p><span>arr.reduce()</span> - зменшує масив значень до одного значення, викликається для кожного елемента масиву для отримання єдиного вихідного значення. Цей метод не змінює оригінальний масив.</p>
			<h3>Сортування</h3>
			<p><span>arr.sort()</span> - використовується для сортування масиву. За замовчуванням він сортує масив у порядку зростання.</p>
			<p><span>arr.reverse()</span> - змінити порядок елементів у масиві на зворотній</p>
			<h3>Перевірка та пошук</h3>
			<p><span>arr.every()</span> - використовується для перевірки того, чи всі елементи в масиві задовольняють певний тест, реалізований за допомогою наданої функції. Він повертає значення типу boolean, яке вказує, чи всі елементи відповідають зазначеній умові. Метод `every()` припиняє виконання, якщо умова є `false` для будь-якого елемента. Якщо всі елементи відповідають умові, він повертає `true`.</p>
			<p><span>arr.some()</span> - використовується для перевірки, чи хоча б один елемент масиву задовольняє певний умовний критерій. Він повертає `true`, якщо хоча б один елемент відповідає умові, і `false`, якщо жоден елемент не задовольняє умові.</p>
			<p><span>arr.includes()</span> - використовується для перевірки того, чи масив містить конкретний елемент. Він повертає значення типу boolean, що вказує, чи зазначений елемент присутній в масиві чи ні.</p>
			<p><span>arr.find()</span> - використовуються для знаходження першого та останнього елементів відповідно, які задовольняють певний умовний критерій в масиві.</p>
			<p><span>arr.indexOf()</span> - використовується для знаходження індексу першого входження елемента в масиві. Якщо елемент не знайдено, метод повертає -1.</p>
			<p><span>arr.findIndex()</span> - використовується для знаходження індексу першого елемента в масиві, який задовольняє певний умовний критерій. Якщо елемент не знайдено, метод повертає -1.</p>
			<h3>Аргументи</h3>
			<p><span>arguments</span> - псевдо-масивов, який містить усі параметри, передані функції. Це дозволяє вам динамічно отримувати доступ до аргументів, навіть якщо вони не були явно вказані у списку параметрів функції. Об'єкт `arguments` доступний у всіх областях функцій. Ви можете отримати доступ до аргументів усередині функції за допомогою об'єкта `arguments`, який діє подібно до масиву.</p>
			<p><span>spread operator (`...`)</span> - використовується для розгортання або розширення елементів, таких як масиви чи об'єкти. Коли використовується в параметрах функції, його називають spread параметром. Коли в виклику - rest. Spread можна використовувати для конкатенації масивів та об'єктів чи створення поверхневої копії масиву.</p>
		</div>
		<div>
			<h2>Object</h2>
			<p><span>obj.prop та obj[prop]</span> - звернення до властивості об'єкта як для визначення, так і для перевизначення</p>
			<p><span>methods</span> - методи, це функції які присвоєні до значення об'єкта викликаються - obj.prop()</p>
			<p><span>this</span> - визначає, що метод звертається до властивостей саме цього об'єкту</p>
			<p><span>hasOwnProperty()</span> - перевірить, чи властивість належить саме об'єкту (власна властивість, повертає `true`, якщо властивість є власною) чи успадкована від прототипу.</p>
			<p><span>Object.values()</span> - повертає масив значень власних перераховуваних властивостей об'єкта в тому ж порядку, як при використанні циклу `for...in`.</p>
			<p><span>Object.keys()</span> - отримує всі ключі об'єкта та повертає їх у вигляді масиву.</p>
			<p><span>Object.entries()</span> - повертає масив пар `[ключ, значення]` у вигляді масиву власних перераховуваних властивостей об'єкта з рядковими ключами.</p>
			<h3>Перетворення об'єкта на масив</h3>
			<p><span>const keys = Object.keys(user);</span> - повертає масив ключів об'єкту</p>
			<p><span>const values = Object.values(user);</span> - повертає масив властивостей об'єкту</p>
			<p><span>const entries = Object.entries(user);</span> - повертає масив масивів - ключ/значення - об'єкту.</p>
			<p>const arr = ['a', 'b', 'c', 'a', 'a', 'b', 'b']</p>
			<p>const set1 = new Set(['a', 'b', 'c', 'a', 'a', 'b', 'b']);</p>
			<p>console.log([...set1])		найпростіший спосіб прибрати дублікати.</p>
		</div>
		<div>
			<h2>Date</h2>
			<p><span>new Date()</span> - Без аргументів – створити об'єкт Date з поточною датою та часом</p>
			<p><span>date.getTime()</span> - перетворити існуючий об'єкт 'Date' на таймстамп</p>
			<p><span>date.toLocaleString()</span> - перетворює дату в рядок, використовуючи конвенції поточної локалі.</p>
			<p><span>date.toLocaleDateString()</span> - повертає рядок лише з частиною дати, відформатований з урахуванням вказаної або типової локалі.</p>
			<p><span>date.toUTCString()</span> - повертає рядкове представлення дати відповідно до Координованого всесвітнього часу (UTC), відображаючи дату та час у часовому поясі UTC.</p>
			<p><span>date.getTimezoneOffset()</span> - повертає зміщення часового поясу в хвилинах для поточної локалі, вказуючи різницю в хвилинах між UTC та місцевим часовим поясом.</p>
		</div>
	</div>
	<script src="script.js"></script>
</body>
</html>